1.  MYSQL  优化 
2.  多线程 JMM 
   JMM  
    原子性
    可见性
    有序性 
     解决方案  JAVA  管程  MASIAN 模型 
                          信号量也可以 解决 
      henpen before 规则 
      线程start 原则 
      程序的顺序性 
      volatile 关键字 
      final 关键字 
      等待通知机制                        
    
    
3.  GC 调优  
4.  Redis 实现分布式锁 
    乐观锁： 读多写少 ；
    悲观锁 ：写多读少 
    公平锁:  所有线程都能得到，不会存在线程饥饿 ，吞吐量相对没有那么高 
    非公平锁：并不是所有线程都能抢到，存在线程饥饿 ，吞吐量相对要高点 
    
5.  多线程  常见的锁 使用什么场景  
6.  Springboot 原理  
7.  kafka 如何保证消息不丢失  
8.  kafka 重平衡机制 


es 
倒排索引  
es 深度分页 
spring  bean 的原理    bean 是安全的吗 ？
分布式事务方案   事务协调者 事务管理者  具体的 深入内容 
 ---  当 你消费mq 异常了之后  会记录异常到异常表  ，然后你定时任务会扫重试 ，那么你怎么保证 写异常表示正常提交的呢 
分布式锁   Redis 分布式锁的细节 
mysql  sql  优化  
kafak   5 分区 配置几个并发 
GC 调优  
spring 如何注册bean  , bean 是安全的？
mysql  主键索引和唯一索引 谁快 ？ 



CAP  理论 
AP : redis   Eureka  
CP : ZK   ETCD 
nacos 默认AP 但是可选    
#false为永久实例，true表示临时实例开启，注册为临时实例
spring.cloud.nacos.discovery.ephemeral=false

mq 用的啥 ？

你的优势 ？ 

为什么离职？ 

使用什么框架 ？  为什么使用hippo 框架  ？ 
hippo 框架是 阿里的的一套 搜索调度框架  
 hippo是一套分布式调度系统。与YARN和K8s的目的相同，都是提供为集群资源调度服务 
 hippo 架构是典型的  master - slave
  hippo镜像化容器运行 
  资源隔离 
  资源预估 
  支持分布式 
  
  
  =======================================================================================================
 1. ACID  
    A: Atomicity  原子性 ； 要么全部执行要么全部不执行 是事务最核心的概念 
                  主要是基于 undo log 来实现的 
                  
    C：Consistency 一致性; 事务追求的最终目标，一致性的实现既要数据库层面的保障 也是需要应用层面的保障 
    
    I：Isolation 隔离性： 保障事务执行尽可能的不受其他事务的影响  ，InnoDb默认的是RR ，RR的实现主要基于锁机制 
                 next-key lock '  MVCC 数据隐列 undo log  版本链 ReadView    
                 
    D:Durability  : 持久性  ：保证事务提交之后 不会因为宕机等原因 导致数据丢失  实现主要基于 redo log   
    
    脏读： 读到未提交的数据 
    不可重复读 ：两次读取同一条数据  两次读到的结果不一样  （读到的其他事务已提交的数据）
    幻读：同一个事务 同一个条件 两次查询 查到的条数不一样 ； 幻读和不可重复读得区别 前者是数据变了 后者是数据行数变了 
    
    
    事务的隔离级别 ：               脏读     不可重复读      幻读  
    Read Uncommited 读未提交       可能        可能        可能         
    Read Commited 读已提交         不可能      可能        可能
    Repeatable Read 可重复读       不可能      不可能      可能
    Serializable    串行化         不可能      不肯能      不可能
    
    事务的实现原理：
         事务的原子性通过 undo log   来实现  记录了一些需要回滚的数据 历史版本  
         事务的持久性 通过 redo log 来现实  只要在redo log 没丢 数据丢了 就可以通过 redo log 恢复   顺序读写   日志先行  。 
         
         redo log 和 binlog 是什么  同步的 ： 两阶段提交  
         事务的隔离性 通过读写锁 +MVCC , 来实现  MVCC多版本控制 
         
         一致性：你是通过 原子性 + 持久性 + 隔离性来实现   最终追求  
    
    
    2. MYSQL 的加密 字段要检索 怎么实现 ？ 
       了解HEX 函数与UNHEX 函数 
       了解AES_ENCRYPT函数与AES_DECRYPT函数
       Java 先把条件转成加密的  再进行查询  
       要么就是用算法实现 
       
       一般数据加密都是 对称加密 
       会问 什么是对称加密 什么是非对称加密  
       不可逆加密：【Hash加密算法/散列算法/摘要算法】
       
       常见的不可逆加密算法有：MD5、SHA、HMAC
       
       【文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥】
       常见的对称加密算法有：AES、DES、3DES、Blowfish、IDEA、RC4、RC5、RC6
       
       两个密钥：公开密钥（publickey）和私有密钥，公有密钥加密，私有密钥解密】
       非对称加密算法有：RSA、DSA（数字签名用）、ECC（移动设备用）、Diffie-Hellman、El Gamal
       Base64编码：Base64只是一种编码方式，不算加密方法。
       
       
       
    3. mysql   深度分页  
       减少回表  覆盖索引  + 索引下推  子查询  优化  
       1. 子查询 
       2. 标签法   本质上就是做记号    避免 OFFSET  
       3. 降级处理 限流 就是 每秒内只让他查询多少次  
       
    4. 越权解决  
       什么是越权 ：
       横向越权： 攻击者 尝试访问与他拥有相同权限的用户的资源 
       纵向越权： 低级别的用户尝试访问高级别的用户资源  
        
       token认证  
       用户认证  
       角色认证 
       缓存辅助  
       
   5. 缓存  与DB 的一致性  
      双写  
      延时双删   设置缓存超时时间
      binlog 同步   +MQ   
   
   6. 如何查询快   
      应用架构  根据业务划分  机器配置情况   网络带宽    IO  数据sql  优化  接口 
      接口的交互方式  应用代码层面  
      多线程  缓存  
      
       
    JMM： 
    原子性  
    可见性 
    有序性 
    heppen-before 
    volitae  
    final 
    synchronized  可重入锁 是java 语言层面的实现   
    等待通知机制 
    JDK AQS 包 
    volatile + CAS + AQS 队列  
    线程本地存储  
    原子类 不变类  
    
    --- 
    缓存雪崩: 
    1. 同一时间缓存中的数据大面积过期
       均匀过期 
       设置热点数据永不过期
       服务降级
    2. Redis 缓存实例发生故障宕机 
       实现服务熔断或者请求限流机制
       事前预防
       构建 Redis 缓存高可靠集群 
       
    缓存击穿
     缓存雪崩是因为大面积的缓存失效，打崩了数据库。而缓存击穿是指某个访问非常频繁的热点数据，大量并发请求集中在这一个点访问，在这个Key失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿了一个洞
     设置热点数据永不过期
     加互斥锁：单机可以使用synchronized、lock，分布式可以使用lua脚本。
     限流  
     
     
    缓存穿透：
     接口层增加校验：用户鉴权、参数校验（请求参数是否合法、请求字段是否不存在等等）；
     缓存空值/缺省值：发生缓存穿透时，我们可以在Redis中缓存一个空值或者缺省值（例如，库存缺省值为0），这样就避免了把大量请求发送给数据库处理，保持了数据库的正常运行。这种方法会存在两个问题：
     如果有大量的Key穿透，缓存空对象会占用宝贵的内存空间。针对这种情况可以给空对象设置过期时间。
     设置过期时间之后，可能会有缓存与数据库不一致的情况。
     布隆过滤器：快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。
   
     Redisson
     
     
     
     
     
     
     
     
     
     
     20题：
       支付接口的设计 ：
        1. 接口的安全性 （越权）
        2. 接口的性能 耗时  
        3. 接口的 网络传输的安全性 
        4. 接口的可用性 
        5. 支付记录的存储 
        6. 支付明细是否清楚 
        7. 整个接口的 幂等性 
        8. 日志记录 异常记录  接口监控 
        9. 考虑到支付失败情况等 
        
       第三方支付平台对账 要考虑测 ： 
        1. 安全性 支付公司需要保护好账务数据的安全性，确保数据不被泄露或被非法访问
        2，时间性 对账过程需要及时进行，及时发现并纠正异常数据，避免因为时间延误而产生更大的风险和损失
        3. 准确性 对账数据的准确性是保证对账过程有效性的基础，支付公司需要认真核对和校对数据，避免错误和漏洞的发生 
        4.合规性：支付公司需要遵守相关的法规和规定，确保对账过程的合规性和规范性。
        第三方支付平台对账是保证支付公司业务准确性和合规性的关键步骤。通过对账过程，
        支付公司可以发现并纠正异常数据，提高支付公司的业务稳定性和信任度。
        同时，支付公司在对账过程中需要注意安全性、时间性、准确性和合规性等问题，以确保对账过程的有效性和规范性。
         
        
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
 